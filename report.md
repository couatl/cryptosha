# Cryptosha
---------------------------------------------------
### ~~Собирай~~ пиши схемы!
----------------------------------------------------



> [Введение](#Введение)

> [Актуальность проекта](#Актуальность-проекта)

> Немного о функциональных элементах (только для дайверов)

> Структура проекта как библиотеки

>> [Регулирующий файл](#Регулирующий-файл)

>> Базовый элемент

>> Унарные операции

>> Бинарные операции

>> Схема шифрования

>> Графическая схема

>> Утилиты для линейного/дифференциального криптоанализа

>> Парсер команд

>> Интерпретатор

>> Язык программирования схем

>

> Структура приложения

> Способы использования Cryptosha в сторонних проектах

> Способы расширения проекта

>> Добавление нового функционального элемента

>> Изменение синтаксиса языка

>> Добавление команд

> Пример работы приложения 

> Вывод 




## Введение 
Cryptosha - проект, предназначенный для работы с блочными схемами шифрования, а именно сборка схемы, прогон значений через нее и криптоанализ этой схемы. 
Ключевой момент проекта заключается в способе выполнения всех этих операций - они осуществляются с помощью кода. Теперь пользователь может построить схему, 
написав программный код, запустить ее всего одной строкой. Не собирайте схемы - пишите их. 

## Актуальность проекта 
Есть огромное количество подобных проектов с подобным функционалом, но ни один из них не закроет нам семестр по АЯ.


## Структура проекта как библиотеки
### Регулирующий файл

Все необходимые для функционирования библиотеки типы, функции и константы содержатся в файле settings.h. Так как изначально проект делился на 3 части:
- система виртуальных функциональных элементов и схемы
- разработка необходимых утилит для дифференциального и линейного криптоанализов (далее будем говорить просто - криптоанализ)
- разработка синтаксического анализатора и интерпретатора 
Для избежания болшинства конфликтов типов и методов, а так же расположения объектов в пространствах имен, был создан этот регулирующий файл. Если представлять весь проект как сеть заголовочных файлов, то settings.h - исток сети.

В этом же файле сразу показана общая структура проекта, выражающаяся в 2-х namespace'ах - cry и cryptosha.
```c++
namespace cryptosha {

	using scheme = cry::elements::graphic_scheme; // класс - схема, реализующая блочный шифр

	class console_reader;     // синтаксический анализатор
	class interpretator;      // интерпретатор програмного кода

	class analysis;           // класс, предоставляющий интерфейс для криптоанализа
}
```

Смысл пространствоа имен `cryptosha` - в отсутствии ненужных пользователю типов, функций и тд. Все, что нужно для надпроекта - интерпретатор и графические схемы (о них отдельно и позже).
Все, что требуется для контроля проекта содержится в пространстве имен `cry` (лишь за несколько дней до дедлайна это имя стало говорящим, а вообще - сокращение от названия проекта).
О регулирующем файле будет сказано практически во всех последующих главах, поэтому не стоит тут останавливаться на этом файле.

### Базовый элемент

```c++

class elements::basic_element 
{

public ctors:
	explicit basic_element(iosize_t::type size_in, iosize_t::type size_out);

	explicit basic_element(const basic_element&) = default;
//	explicit basic_element(basic_element&&) = default;

public methods:
	basic_element& set_input(const bitset_t& input_bitset);
	basic_element& set_input(bitset_t&& input_bitset);
	basic_element& set_input(const string_t& input_bitstr);
	basic_element& set_input(string_t&& input_bitstr);
	basic_element& set_input(int_t value);

	basic_element& set_null();

	virtual bitset_t run() = 0;

	
	bitset_t input() const;
	bitset_t output() const;

	bitset_t& input_ref();
	bitset_t& output_ref();

	bool input(size_type bit);
	bool output(size_type bit);

	
	iosize_t size()  const;
	iosize_t::type osize() const;
	iosize_t::type isize() const;

	inline static size_type get_element_count();

	dtor virtual ~basic_element();

protected data:
	iosize_t  m_size;

	bitset_t  m_input;
	bitset_t  m_output;

protected states:
	state_t m_state;

private static_data:
	static size_type  g_obj_count;

private methods:	
	inline void _ctor();

};
```
